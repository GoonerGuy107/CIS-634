%% ---------------------------------------------------
%% Kyle Peppe
%% CIS 634 Project 4 Report
%% ---------------------------------------------------
\documentclass{report}

\title{Project 4 Report}
\author{Kyle Peppe}
\date{\today}

%% ---------------------------------------------------
%% 634format specifies the format of our reports
%% ---------------------------------------------------
\usepackage{634format}

%% ---------------------------------------------------
%% enumerate 
%% ---------------------------------------------------
\usepackage{enumerate}

%% ---------------------------------------------------
%% listings is used for including our source code in reports
%% textcomp provides additional symbols
%% ---------------------------------------------------
\usepackage{listings}
\usepackage{textcomp}

%% ---------------------------------------------------
%% Packages for math environments
%% ---------------------------------------------------
\usepackage{amsmath}

%% ---------------------------------------------------
%% Packages for URLs and hotlinks in the table of contents
%% and symbolic cross references using \ref
%% ---------------------------------------------------
\usepackage{hyperref}

%% ---------------------------------------------------
%% Packages for using HOL-generated macros and displays
%% ---------------------------------------------------
\usepackage{holtex}
\usepackage{holtexbasic}
\input{commands}

\begin{document}

%% --------------------------------------------------- 
%% The listings  parameter "language" is set to "ML"
%% ---------------------------------------------------
\lstset{language=ML}


\maketitle{}

\begin{abstract}
  This project was mainly to use ML to set a goal and then use ML
  tactics to prove a goal or to set a theorem. The exercises became
  more difficult with chapter 10 being a bit more difficult. I have
  completed the exercises 9.5.1, 9.5.2, 9.5.3, 10.4,1, 10.4.2, and
  10.4.3.
	\begin{itemize}
		\item Problem Statement
		\item Relevant Code
		\item Test Results
	\end{itemize}
        This project includes the following packages:
	\begin{description}
		\item[\emph{634format.sty}] A format style for this course
		\item[\emph{listings}] Package for displaying and inputting ML source code
		\item[\emph{holtex}] HOL style files and commands to display in the report
	\end{description}
        This document also demonstrates my ability to :
	\begin{itemize}
		\item Easily generate a table of contents,
		\item Refer to chapter and section labels
	\end{itemize}.
\end{abstract}

\tableofcontents{}

\begin{acknowledgments}
  I would like to acknowledge the 2 professors, Professor Chin and 
  Professor Hamner, that have helped me begin to understand this new
  ML programming language. Also to Syracuse University for accepting
  me to this Masters program in Cybersecurity.
\end{acknowledgments}

\chapter{Executive Summary}
\label{cha:executive-summary}
\textbf{All requirements for this project are satisfied.}
Specifically,
\begin{description}
\item[Report Contents] \ \\
  Our report has the following content:
  \begin{enumerate}[{}]
  \item Chapter~\ref{cha:executive-summary}: Executive Summary
  \item Chapter~\ref{cha:9-5-1}: Exercise 9.5.1
    \begin{enumerate}[{}]
    \item Section~\ref{problem-statement-9-5-1}: Problem Statement
    \item Section~\ref{rel-code-9-5-1}: Relevant Code 
    \item Section~\ref{trans-9-5-1}: Session Transcripts
    \end{enumerate}
  \item Chapter~\ref{cha:9-5-2}: Exercise 9.5.2
    \begin{enumerate}[{}]
    \item Section~\ref{problem-statement-9-5-2}: Problem Statement
    \item Section~\ref{rel-code-9-5-2}: Relevant Code
    \item Section~\ref{trans-9-5-2}: Session Transcripts
    \end{enumerate}
  \item Chapter~\ref{cha:9-5-3}: Exercise 9.5.3
    \begin{enumerate}[{}]
    \item Section~\ref{problem-statement-9-5-3}: Problem Statement
    \item Section~\ref{rel-code-9-5-3}: Relevant Code
    \item Section~\ref{trans-9-5-3}: Session Transcripts
    \end{enumerate}
\item Chapter~\ref{cha:10-4-1}: Exercise 10.4.1
    \begin{enumerate}[{}]
    \item Section~\ref{problem-statement-10-4-1}: Problem Statement
    \item Section~\ref{rel-code-10-4-1}: Relevant Code 
    \item Section~\ref{trans-10-4-1}: Session Transcripts
    \end{enumerate}
  \item Chapter~\ref{cha:10-4-2}: Exercise 10.4.2
    \begin{enumerate}[{}]
    \item Section~\ref{problem-statement-10-4-2}: Problem Statement
    \item Section~\ref{rel-code-10-4-2}: Relevant Code
    \item Section~\ref{trans-10-4-2}: Session Transcripts
    \end{enumerate}
  \item Chapter~\ref{cha:10-4-3}: Exercise 10.4.3
    \begin{enumerate}[{}]
    \item Section~\ref{problem-statement-10-4-3}: Problem Statement
    \item Section~\ref{rel-code-10-4-3}: Relevant Code
    \item Section~\ref{trans-10-4-3}: Session Transcripts
    \end{enumerate}
 \item Appendix~\ref{cha:source-code}: Source Code
  \end{enumerate}
\item[Reproducibility in ML and \LaTeX{}] \ \\
  The ML and \LaTeX{} source files compile with no errors.
\end{description}


\chapter{Excercise 9.5.1}
\label{cha:9-5-1}

\section{Problem statement}
\label{problem-statement-9-5-1}
Do a tactic based proof of the absorption rule:
\begin{lstlisting}[frame=tblr]
 ``!(p:bool)(q:bool).(p ==> q) ==> p ==> p /\ q``
\end{lstlisting}

\section{Relevant Code}
\label{rel-code-9-5-1}
\begin{lstlisting}[frame=TBlr]
(* Exercise 9.5.1					*)
val absorptionRule =
TAC_PROOF
(
	([], ``!(p:bool)(q:bool).(p ==> q) ==> p ==> p /\ q``),
	(REPEAT STRIP_TAC THENL
	[(ACCEPT_TAC (ASSUME ``p:bool``)),
	RES_TAC])
);

(* Save the theorem					*)
val _ = save_thm("absorptionRule", absorptionRule);

\end{lstlisting}

\section{Session Transcript}
\label{trans-9-5-1}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}
> val absorptionRule =
TAC_PROOF
(
	([], ``!(p:bool)(q:bool).(p ==> q) ==> p ==> p /\ q``),
	(REPEAT STRIP_TAC THENL
	[(ACCEPT_TAC (ASSUME ``p:bool``)),
	RES_TAC])
);
# # # # # # # val absorptionRule =
   |- !(p :bool) (q :bool). (p ==> q) ==> p ==> p /\ q:
   thm
> 
\end{verbatim}
  \end{scriptsize}
\end{session}

\chapter{Excercise 9.5.2}
\label{cha:9-5-2}

\section{Problem statement}
\label{problem-statement-9-5-2}
Do a tactic based proof of the absorption ruleProve the following theorem:
\begin{lstlisting}[frame=tblr]
``!(p:bool)(q:bool)(r:bool)(s:bool).(p ==> q) /\ (r ==> s) ==> p \/ r ==> q \/ s``)
\end{lstlisting}

\section{Relevant Code}
\label{rel-code-9-5-2}
\begin{lstlisting}[frame=TBlr]
val constructiveDilemmaRule =
TAC_PROOF
(
	([], ``!(p:bool)(q:bool)(r:bool)(s:bool).
	(p ==> q) /\ (r ==> s) ==> p \/ r ==> q \/ s``),
	(REPEAT STRIP_TAC THEN
	RES_TAC THEN
	ASM_REWRITE_TAC[] THEN
	RES_TAC THEN
	ASM_REWRITE_TAC[])
);
\end{lstlisting}

\section{Session Transcript}
\label{trans-9-5-2}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}
> val constructiveDilemmaRule =
TAC_PROOF
(
	([], ``!(p:bool)(q:bool)(r:bool)(s:bool).
	(p ==> q) /\ (r ==> s) ==> p \/ r ==> q \/ s``),
	(REPEAT STRIP_TAC THEN
	RES_TAC THEN
	ASM_REWRITE_TAC[] THEN
	RES_TAC THEN
	ASM_REWRITE_TAC[])
);
# # # # # # # # # # val constructiveDilemmaRule =
   |- !(p :bool) (q :bool) (r :bool) (s :bool).
     (p ==> q) /\ (r ==> s) ==> p \/ r ==> q \/ s:
   thm
> 
\end{verbatim}
  \end{scriptsize}
\end{session}

\chapter{Excercise 9.5.3}
\label{cha:9-5-3}

\section{Problem statement}
\label{problem-statement-9-5-3}
For this exercise we use prove tac on the Exercises 9.5.1 and 9.5.2.

\section{Relevant Code}
\label{rel-code-9-5-3}
\begin{lstlisting}[frame=TBlr]
val absorptionRule2 =
TAC_PROOF
(
	([], ``!(p:bool)(q:bool).(p ==> q) ==> p ==> p /\ q``),
	(PROVE_TAC[])
);

val constructiveDilemmaRule2 =
TAC_PROOF
(
	([], ``!(p:bool)(q:bool)(r:bool)(s:bool).
	(p ==> q) /\ (r==> s) ==> p \/ r ==> q \/ s``),
	(PROVE_TAC[])
);
\end{lstlisting}

\section{Test Case}
\label{trans-9-5-3}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}
> val absorptionRule2 =
TAC_PROOF
(
	([], ``!(p:bool)(q:bool).(p ==> q) ==> p ==> p /\ q``),
	(PROVE_TAC[])
);
# # # # # Meson search level: ........
val absorptionRule2 =
   |- !(p :bool) (q :bool). (p ==> q) ==> p ==> p /\ q:
   thm
> val constructiveDilemmaRule2 =
TAC_PROOF
(
	([], ``!(p:bool)(q:bool)(r:bool)(s:bool).
	(p ==> q) /\ (r==> s) ==> p \/ r ==> q \/ s``),
	(PROVE_TAC[])
);
# # # # # # Meson search level: ................
val constructiveDilemmaRule2 =
   |- !(p :bool) (q :bool) (r :bool) (s :bool).
     (p ==> q) /\ (r ==> s) ==> p \/ r ==> q \/ s:
   thm
> 
\end{verbatim}
  \end{scriptsize}
\end{session}

\chapter{Excercise 10.4.1}
\label{cha:10-4-1}

\section{Problem statement}
\label{problem-statement-10-4-1}
Prove the goal without using prove tac
\begin{lstlisting}[frame=tblr]
([``!x:'a.P(x) ==> M(x)``, ``(P:'a -> bool)(s:'a)``], ``(M:'a -> bool)(s:'a)``)
\end{lstlisting}

\section{Relevant Code}
\label{rel-code-10-4-1}
\begin{lstlisting}[frame=TBlr]
val problem1_thm =
TAC_PROOF
(
	([``!x:'a.P(x) ==> M(x)``, ``(P:'a -> bool)(s:'a)``], ``(M:'a -> bool)(s:'a)``),
	(PAT_ASSUM ``!x.t`` (fn th => (ASSUME_TAC (SPEC ``s`` th))) THEN
	RES_TAC)
);
\end{lstlisting}

\section{Test Case}
\label{trans-10-4-1}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}
> val problem1_thm =
TAC_PROOF
(
	([``!x:'a.P(x) ==> M(x)``, ``(P:'a -> bool)(s:'a)``], ``(M:'a -> bool)(s:'a)``),
	(PAT_ASSUM ``!x.t`` (fn th => (ASSUME_TAC (SPEC ``s`` th))) THEN
	RES_TAC)
);
# # # # # # <<HOL message: inventing new type variable names: 'a>>
val problem1_thm =
    [..] |- (M :'a -> bool) (s :'a):
   thm
> 
\end{verbatim}
  \end{scriptsize}
\end{session}

\chapter{Excercise 10.4.2}
\label{cha:10-4-2}

\section{Problem statement}
\label{problem-statement-10-4-2}
Prove the goal without using prove tac
\begin{lstlisting}[frame=tblr]
([``p /\ q ==> r``, ``r ==> s``, ``~s``], ``p ==> ~q``)
\end{lstlisting}

\section{Relevant Code}
\label{rel-code-10-4-2}
\begin{lstlisting}[frame=TBlr]
val problem2_thm =
TAC_PROOF
(
	([``p /\ q ==> r``, ``r ==> s``, ``~s``], ``p ==> ~q``),
	(REPEAT STRIP_TAC THEN
	REPEAT RES_TAC)
);
\end{lstlisting}

\section{Test Case}
\label{trans-10-4-2}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}
> val problem2_thm =
TAC_PROOF
(
	([``p /\ q ==> r``, ``r ==> s``, ``~s``], ``p ==> ~q``),
	(REPEAT STRIP_TAC THEN
	REPEAT RES_TAC)
);
# # # # # # val problem2_thm =
    [...] |- (p :bool) ==> ~(q :bool):
   thm
> 
\end{verbatim}
  \end{scriptsize}
\end{session}

\chapter{Excercise 10.4.3}
\label{cha:10-4-3}

\section{Problem statement}
\label{problem-statement-10-4-3}
Prove the goal without using prove tac
\begin{lstlisting}[frame=tblr]
([``~(p /\ q)``, ``~p ==> r``, ``~q ==> s``], ``r \/ s``)
\end{lstlisting}

\section{Relevant Code}
\label{rel-code-10-4-3}
\begin{lstlisting}[frame=TBlr]
val problem3_thm =
TAC_PROOF
(
	([``~(p /\ q)``, ``~p ==> r``, ``~q ==> s``], ``r \/ s``),
	(PAT_ASSUM ``A ==> B`` (fn th => ASSUME_TAC(REWRITE_RULE[]
	(DISJ_IMP(ONCE_REWRITE_RULE [DISJ_SYM] (IMP_ELIM th))))) THEN
	PAT_ASSUM ``~(A /\ B)`` (fn th => (ASSUME_TAC(REWRITE_RULE[]
	(DISJ_IMP(REWRITE_RULE [DE_MORGAN_THM] th))))) THEN
	ASSUME_TAC(IMP_TRANS (ASSUME ``p ==> ~q``) (ASSUME ``~q ==> s``)) THEN
	ASSUME_TAC(IMP_TRANS (ASSUME ``~r ==> p``) (ASSUME ``p ==> s``)) THEN
	PAT_ASSUM ``A ==> B`` (fn th => (ASSUME_TAC (REWRITE_RULE[] (IMP_ELIM th))))
	THEN ASM_REWRITE_TAC[])
);
\end{lstlisting}

\section{Test Case}
\label{trans-10-4-3}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}
> val problem3_thm =
TAC_PROOF
(
	([``~(p /\ q)``, ``~p ==> r``, ``~q ==> s``], ``r \/ s``),
	(PAT_ASSUM ``A ==> B`` (fn th => ASSUME_TAC(REWRITE_RULE[]
	(DISJ_IMP(ONCE_REWRITE_RULE [DISJ_SYM] (IMP_ELIM th))))) THEN
	PAT_ASSUM ``~(A /\ B)`` (fn th => (ASSUME_TAC(REWRITE_RULE[]
	(DISJ_IMP(REWRITE_RULE [DE_MORGAN_THM] th))))) THEN
	ASSUME_TAC(IMP_TRANS (ASSUME ``p ==> ~q``) (ASSUME ``~q ==> s``)) THEN
	ASSUME_TAC(IMP_TRANS (ASSUME ``~r ==> p``) (ASSUME ``p ==> s``)) THEN
	PAT_ASSUM ``A ==> B`` (fn th => (ASSUME_TAC (REWRITE_RULE[] (IMP_ELIM th))))
	THEN ASM_REWRITE_TAC[])
);
# # # # # # # # # # # # val problem3_thm =
    [...] |- (r :bool) \/ (s :bool):
   thm
> 
\end{verbatim}
  \end{scriptsize}
\end{session}

\appendix{}

\chapter{Source code}
\label{cha:source-code}
\lstinputlisting{../exercise9Script.sml}

\lstinputlisting{../exercise10Script.sml}

\end{document}